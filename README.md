
$limit は省略したら「デフォルトの制限」
０でも動くようにする（０だと出てこない）

## Resources

  複数のメソッドを持つ（単一種リソースの入出力をまとめて持つ）
  インターフェースはDDD的原則のために用意したもので、実装と１：１
  利用できる依存オブジェクトは、他のResrouceのみ
  ディレクトリ分けは「取り出されるエンティティ」（≒ 保存するエンティティ）
  クラス分けはそのエンティティの用途
  以下のメソッドを標準的に使用する（ただし以下の機能で十分な、シンプルな入出力リソースに限る）
    R  getOne
       getList ...無条件検索 なにか条件をつけるなら専用のメソッドを作る(検索条件がたくさんあるなら引数もたくさんもたせる)
    C  addOne  ...[depricated]
       addList
    CU  upsert ...[depricated]
        storeOne
        storeList
    D  removeOne
       removeList

  SQLに近いプリミティブな単一リソースのデータ入出力に徹するべきか？
  ビジネスロジックも含んだ賢いリソースであるべきか？
  基本的には後者。
  Eloquent、Redis、PHPなどを総動員して、Usecaseから要求されるエンティティの生成と永続化を担う。
  （生成であり、読み込みではない。生成のための永続化であり、恒久的な保存ではない）
  プリミティブなリソースはSQLを単純化しすぎて活かしきれず、複雑なSQLを生成しようとして上位レイヤーが複雑化する。
  だったら最初からSQLもうまく活用して「要求されたロジックを効率よくこなす」賢いリソースを
  必要最小限の数用意するほうがいい。
  シンプルなリソースは「単純なロジックしか無い」賢いリソースである。


## MediaAccess

  関数クラス（1クラス1機能）
  外部媒体ごとに異なる実装を持つ MediaFactoryで定義
  利用できる依存オブジェクトは、他のMediaAccessのみ
  件数制限 limit は「必要十分な数」なので超えることがある


## Usecase

  関数クラス（1クラス1機能）
  インターフェースはDDD的原則のために用意したもので、実装と１：１
  利用できる依存オブジェクトは、他のUsecase、MediaAccess、Resrouce




# Worker, Job, Usecase, MediaAccess の関係

Worker     次に実行するJobを決定、Job実行指示、結果を記録
Job     Usecaseの呼び出し、再開指示、実行結果を報告 実行時間制限がありUsecaseに分配する
Job     MediaAccessの結果を受けてアプリケーション固有の処理 実行時間制限あり
MediaAccess 指定件数(小さい数値)拾ってきて続きがあるかを返答 その続きから再開できる 実行時間制限がない

NEXT_CURSORの内容は、そのクラスの固有のもの（配下のMediaAccessや外部サービスのそれに識別子を付けたりしてOK）
